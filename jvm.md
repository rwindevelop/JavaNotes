# 变量存储位置

### 局部变量

存在于方法中，所以在栈中，基本类型变量在栈中保存的直接是值，引用类型变量保存的是指向堆的地址。局部变量存储在栈中，当方法执行完后，局部变量随之消失。

### 成员变量

存在于类中，成员变量存储在堆中的对象里面

### 静态变量

 堆

# java程序执行

![Javaload](C:\Users\wangqianlong\Desktop\Java\images\Javaload.jpg)

如上图所示，首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）

# 方法区

方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

JDK1.8中方法区的实现为元空间，在本地内存而不在JVM中，类加载过程生成的Class对象存储在堆中

# 堆

java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。

新生代 

老年代

# Java栈

当java的方法执行时，会在栈中分配内存，Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。下图表示了一个Java栈的模型：

局部变量表用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的

###  ![JavaStatck](C:\Users\wangqianlong\Desktop\Java\images\JavaStatck.jpg)



# 类加载

JVM把class文件加载到内存，并对数据进行校验、准备、解析、初始化，最终形成JVM可以直接使用的Java类型的过程。‘

### 加载时机

1. 创建类的实例
2. 访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant  variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。
3. 访问类的静态方法
4. 反射如(Class.forName("my.xyz.Test"))
5. 当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化
6. 虚拟机启动时，定义了main()方法的那个类先初始化

### 加载过程

#### 加载

   "加载"是"类加载"这个过程的一个阶段，是 “类加载”过程中最先开始进行的操作，加载阶段，虚拟机需要完成三件事：
    1、 根据类的全限定名获取定义此类的二进制字节流；
    2、 将这个字节流代表的静态存储结构转换为方法区的运行时数据结构；
    3、 在方法区中为这个类生成一个java.lang.Class对象，作为方法区这个类的访问入口。JDK1.8中为元空间

Java的虚拟机规范并没有规定从哪里获取、怎样获取二进制字节流，这个阶段也是用户参与度最高的阶段，用户可以根据二进制文件的不同形式在自定义类加载器控制字节流的获取方式，比如成熟的二进制获取方式和类加载器有：
1、 从Zip包中读取二进制文件，比如常见的jar、war、ear包；
2、 运行时动态生成，比如动态代理技术，在java.lang.reflect.Proxy中，使用 ProxyGenerator.generateProxyClass为各种就接口生成形如"*$Proxy"的代理类的二进制字节流；
3、 从网络中获取，这种场景比较常见的是Applet应用；
4、 其他文件生产，比如jsp文件生成的二进制class文件；

数组的加载跟普通类型加载有所不同，因为数组本身不是通过类加载器加载产生的，数组类是虚拟机自动生成的，但是数组的类型是通过类加载器完成加载的，数组类的创建过程需要遵循以下规则：
1、 如果数组的类型是引用类型，则引用类型需要使用递归来进行加载，并且数组需要被加载该数组类型的类加载器的命名空间上进行标识；
2、 如果数组的类型不是引用类型，是基本数据类型，Java虚拟机将会把数组标记为与引导类加载器关联；
3、 数组的可见性与数组类型的可见性保持一致，如果数组类型是基本类型，则默认可见性为public。

#### 验证

验证是类加载的第二个阶段，这个阶段也是持续时间最长(从阶段连续性来说)，这个阶段从加载开始进行，一直进行到解析阶段结束。验证是为了保证class文件中的内容是符合虚拟机规范的二进制字节流，防止通过执行一些不安全的二进制字节流而导致虚拟机奔溃。 

Java语言本身是安全的语言，它做了很多的安全校验，比如类型转换、非正常的分支语句跳转、不合法的名称定义等等。但是我们知道，Java虚拟机并不只是执行Java语言编译后的class文件，它可以执行所有的二进制字节流文件(只要符合文件规范)，所以我们不能保证其他的文件是合法的，所以需要进行一些安全校验，以保证虚拟机执行的代码是不会危害虚拟机本身安全的。从整体来看，类加载过程的验证阶段可以分为四个部分：文件格式验证、元数据验证、字节码验证和符号引用验证。

#### 准备

准备阶段是正式为类变量分配内存并**设置类变量初始值**的阶段。这些变量所使用的内存都将在方法去中分配，这个阶段分配的内存仅包括类变量（static修饰），实例变量将会在对象初始化阶段随着对象一起分配在堆中。

**对于设置类变量初始值**  如 public static int a=123;

**此步骤中仅仅把a设为初始值0，在初始化阶段把a设为123**

#### 解析

解析阶段是虚拟机将符号引用转化为直接引用的过程，符号引用在之前已经介绍过了，在class文件中以形如"CONSTANT_Class_info"、"CONSTANT_Fieldref_info"、"CONSTANT_Methodref_info"格式存在，
参考 https://www.zhihu.com/question/30300585/answer/51335493

#### 初始化

##### 触发初始化条件

- new
- 反射
- main方法的主类
- 初始化类时发现父类没有初始化，则先触发父类的初始化

注意以下几种情况不会执行类初始化：

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 通过类名获取Class对象，不会触发类的初始化。
4. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
5. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
   

##### 流程

这个阶段主要是对类变量初始化，是执行类构造器的过程。

换句话说，只对static修饰的变量或语句进行初始化。

如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

### 类加载器

把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。这样的好处在于，我们可以自行实现类加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。系统自带的类加载器分为三种：

1. 启动类加载器。
2. 扩展类加载器。
3. 应用程序类加载器。

### 双亲委派机制

如果一个类加载器收到了类加载器的请求.它首先不会自己去尝试加载这个类.而是把这个请求委派给父加载器去完成.每个层次的类加载器都是如此.因此所有的加载请求最终都会传送到Bootstrap类加载器(启动类加载器)中.只有父类加载反馈自己无法加载这个请求(它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载。

双亲委派模型的优点：java类随着它的加载器一起具备了一种带有优先级的层次关系.

例如类java.lang.Object,它存放在rt.jar之中.无论哪一个类加载器都要加载这个类.最终都是双亲委派模型最顶端的Bootstrap类加载器去加载.因此Object类在程序的各种类加载器环境中都是同一个类.相反.如果没有使用双亲委派模型.由各个类加载器自行去加载的话.如果用户编写了一个称为“java.lang.Object”的类.并存放在程序的ClassPath中.那系统中将会出现多个不同的Object类.java类型体系中最基础的行为也就无法保证.应用程序也将会一片混乱.

##### 	JVM在搜索类的时候，又是如何判定两个class是相同的呢？

​    JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。现在通过实例来验证上述所描述的是否正确：



# JVM调优

## 查看JVM运行时参数

- -xx:+PrintFlagsInitial  查看运行时JVM初始值
- -xx:+PrintFlagsFinal   查看运行时JVM最终值

## JPS

查看运行的java进程

```
C:\Users\wangqianlong>jps -l
256 com.example.ajax.AjaxApplication
```

## jinfo

  jinfo也是jvm中参与的一个命令，可以查看运行中jvm的全部参数，还可以设置部分参数。

查看堆参数

```
jinfo -flag MaxHeapSize 256(进程ID)
```

```
C:\Users\wangqianlong>jinfo -flag MaxHeapSize 256
-XX:MaxHeapSize=2124414976
```

## jstat

查看jvm统计信息

- 类加载

```

C:\Users\wangqianlong>jstat -class 256（PID） 1000 10 每个1000ms输出一次，总共输出十次
Loaded  Bytes  Unloaded  Bytes     Time
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
  7458 13442.3        1     0.9       6.42
```



- 垃圾收集 
- JIT编译

# 垃圾回收

## 垃圾回收算法

标记-清除：标记阶段标记要回收的垃圾，清除阶段直接清除垃圾，会产生内存碎片

复制：年轻代回收，把存活的对象移动到另一部分内存中，然后把其他内存全部清空

标记-整理 标记阶段标记要回收的垃圾，整理阶段把垃圾向内存的一段移动并清除，不会产生内存碎片

分代收集算法
分代收集算法并没有多么高深的原理，只是将前面的算法进行了合理组合与利用。根据对象存活周期的不同将内存划分为几块，一般将Java堆分为新生代和老年代。在新生代中，每次垃圾收集时会有大量的对象死去，只有少量存活，使用复制收集算法；老年代中对象存活率较高，没有额外空间对其进行分配担保，使用标记-清除算法或标记-整理来进行回收。


## JVM垃圾回收

Young区采用复制算法

Old区采用标记-清除 或者标记-整理

### 对象分配

对象优先在Eden区分配

大对象直接进入老年代：-XX:PretenureSizeThreshold

长期存活的对象进入老年代：-XX:MaxTenuringThreshold  -XX:+PrintTrnuringDistribution  -XX:TargetSurvivoRatio

### 垃圾收集器

#### 串行收集器 Serial:Serial、Serial Old

概念：垃圾收集线程线程串行执行 

开启串行收集器：-XX:+UseSerialGc(作用与新生代)   -XX:+UseSerialOldGc（作用于老年带）

#### 并行收集器 Parallel:Parallel Scavenge、Parallel Old 

概念： 指多条垃圾收集线程并行工作，但此用户线程仍处于等待状态

开启串行收集器：-XX:+UseParallelGc(作用与新生代)   -XX:+UseParallelOldGc（作用于老年带）

#### 并发收集器Concurrent:CMS、G1

概念：用户线程和垃圾线程同时执行（但不一定时并行的，可能会交替执行）垃圾收集线程在执行的时候不会停顿用户程序的运    行。适合对响应时间有要求的场景，比如Web

##### CMS垃圾收集器

作用于老年代

采用标记清除算法

与CMS收集器适配的新生代收集器，如果开启CMS，新生代默认为UseParNewlGc收集器

开启CMS收集器  -XX:+UseConcMarkSweepGc   -XX:+UseParNewlGc

##### G1垃圾收集器

标记整理算法

开启G1收集器  -XX:+UseG1Gc

 # GC

## 新生代GC（MinorGC/Young GC）

指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 MinorGC 非常频繁，一般回收速度也比较快。

### MinorGC

从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 **Minor GC**。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：

1. 当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。
2. 内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。
3. 执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。
4. 质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。

#### MinorGC过程(Young GC)

​    虚拟机在进行MinorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间

​    1、如果大于的话，直接执行MinorGC

​    2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC

​    3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC

​    4、如果大于的话，执行MinorGC



 ## 老年代GC（MajorGC/FullGC）

指发生在老年代的 GC，出现了 MajorGC，经常会伴随至少一次的 MinorGC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）。MajorGC 的速度一般会比 MinorGC 慢 10 倍以上。

### FullGC

是清理整个堆空间—包括年轻代和永久代，指发生在老年代的 GC，出现了 **MajorGC**，经常会伴随至少一次的 **MinorGC**（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 **MajorGC** 的策略选择过程）。**MajorGC** 的速度一般会比 **MinorGC** 慢 10 倍以上。

（1） 老年代空间不足

如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发**Full GC**。为了避免这种情况，最好就是不要创建太大的对象。

（2）方法区空间不足

方法区空间满了。方法区中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：OOM 。为避免元空间占满造成Full GC现象，可采用的方法为增大Meta Space空间或转为使用CMS GC。

（3）Young GC出现promotion failure

promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.

（4）统计**Young GC**发生时晋升到老年代的平均总大小大于老年代的空闲空间

在发生**Young GC**是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳**Young GC**晋升的对象的平均大小，如果不安全，就不会执行**Young GC**,转而执行**Full GC**。

（5）显式调用System.gc方法



# Object的**finalize**方法

如果对象在进行可达性分析后没有与GC Roots相连接的引用链，进行第一次标记；并且进行一次筛选：**此对象是否有必要执行finalize()方法**。任何一个对象的finalize()方法只会被系统自动调用一次，调用过finalize()方法而逃脱死亡的对象，第二次将不会再调用。

(1)没有必要执行的情况：对象已死，可以回收

对象没有覆盖 finalize() 方法
finalize() 方法已经被JVM调用过

(2) 有必要执行的情况

将有必要执行 finalize() 方法的对象放入F-Queue队列中
稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行

- 如果对象在其finalize()方法中重新与引用链上任何一个对象建立关联，第二次标记时会将其移除**即将回收**的集合
- 否则，认为对象已死，可以回收













