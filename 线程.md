## 线程

### 线程的状态

- **新建状态**：线程对象被创建后，就进入了新建状态。此时它和其他Java对象一样，仅仅由Java虚拟机分配了内存，并初始化其成员变量值。
- **就绪状态**：也被称为“可执行状态”。线程对象被调用了该对象的start()方法，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器。处于就绪状态的线程，随时可能被CPU调度执行，取决于JVM中线程调度器的调度。
- **运行状态**：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
- **阻塞状态** （ wait（），sleep（）,yield(),join() ）
  1. wait() 让当前线程进入阻塞状态，直到唤醒，会释放锁。
  2. yield() ,sleep() 不会释放锁。
  - **死亡状态**：线程执行完了、因异常退出了run()方法或者直接调用该线程的stop()方法（容易导致死锁，现在已经不推荐使用），该线程结束生命周期。

### **notify()、nofityAll()方法**  

　在Object.java中，定义了wait(), notify()和notifyAll()等方法。

​    notify()        -- 唤醒在此对象监视器上等待的单个线程，使其进入“就绪状态”。　　
　notifyAll()   -- 唤醒在此对象监视器上等待的所有线程，使其进入“就绪状态”。

### **Synchronized关键字** 

在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。  例如，现在有个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” ——  线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。

**第一条** :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，**其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。**
**第二条** :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，**其他线程仍然可以访问“该对象”的非同步代码块。**
**第三条** :   当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，**其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。**

 当synchronized**修饰一个static**方法时，多线程下，获取的是**类锁**（即Class本身，注意：不是实例），作用范围是整个静态方法，作用的对象是这个类的所有对象。

 当synchronized修饰一个**非static方法**时，多线程下，获取的是**对象锁**（即类的实例对象），作用范围是整个方法，作用对象是调用该方法的对象。

### 创建线程

1. 继承Thread类，覆写run方法 

   ```
   public class FristThread extends Thread {
       @Override
       public void run() {
           synchronized (this) {
               super.run();
               System.out.println("初始化");
               notify();
               System.out.println("It is Frist Thread");
           }
       }
   }
   ```

2. 继承Runnable接口

   ```
   public class FristRunable implements Runnable {
       public void run() {
           System.out.println("It is Frist Runnable");
       }
   }
   ```

### run方法和start区别

- **start**：用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。
- **run**：run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。

### 引起线程安全问题

- 静态变量：线程非安全。静态变量即类变量，位于方法区，为所有对象共享，共享一份内存，一旦静态变量被修改，其他对象均对修改可见，故线程非安全。

- 实例变量（成员变量）：单例模式（只有一个对象实例存在）线程非安全，非单例线程安全。实例变量为对象实例私有，在虚拟机的堆中分配，若在系统中只存在一个此对象的实例，在多线程环境下，“犹如”静态变量那样，被某个线程修改后，其他线程对修改均可见，故线程非安全；如果每个线程执行都是在不同的对象中，那对象与对象之间的实例变量的修改将互不影响，故线程安全。

- 局部变量：线程安全。每个线程执行时将会把局部变量放在各自栈帧的工作内存中，线程间不共享，故不存在线程安全问题。

### 如何保证线程安全

在Java中,为了保证多线程读写数据时保证数据的一致性,可以采用两种方式:

synchronized 和 volatile

volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.
volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.
volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.
volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.
volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.

### ThreadLocal

ThreadLocal是给每个线程都创建一个变量副本。

ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享 此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。 

SimpleDataFormat是非线程安全，使用ThreadLocal保证线程安全

```
class SafeDateForamt {  
        static ThreadLocal<DateFormat> threadLocal = new ThreadLocal<DateFormat>() {  
            @Override  
            protected synchronized DateFormat initialValue() {  
               return new SimpleDateFormat("YYYY-MM-DD HH:mm:ss");  
            }  
        };  
        public static Date parse(String dateStr) throws ParseException {  
            return threadLocal.get().parse(dateStr);  
        }  
        public static String format(Date date) {  
            return threadLocal.get().format(date);  
        }  
}  
```

### 可重入锁

当一个线程得到一个对象的锁后，在该锁里执行代码的时候可以再次请求该对象的锁时可以再次得到该对象的锁。（**锁得范围同一个对象**），可重入锁的概念就是：**自己可以获取自己的内部锁**。

**可以避免死锁**

假如有1个线程T获得了对象A的锁，那么该线程T如果在未释放前再次请求该对象的锁时，如果没有可重入锁的机制，是不会获取到锁的，这样的话就会出现死锁的情况。

**ReentrantLock重入锁**

顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对
资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。

1.实现重进入
重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实
现需要解决以下两个问题。
1）线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再
次成功获取。
2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到
该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁 被释放时，计数自减，当计数等于0时表示锁已经成功释放

**Synchronized锁重入**

（1）关键字Synchronized拥有锁重入的功能，也就是在使用Synchronized的时候，当一个线程得到一个对象的锁后，在该锁里执行代码的时候可以再次请求该对象的锁时可以再次得到该对象的锁。

（2）也就是说，当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的**对象锁**时，如果该锁是重入锁,请求就会成功，否则阻塞。

## 线程池



【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程

 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 

说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool:   允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool:   允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 



当一个线程处于睡眠，阻塞状态时，被别的线程打断 就是抛出java.lang.InterruptedException: sleep interrupted异常

MyTask

```
@Override
public void run() {
    try {
        System.out.println(this.toString() + " is running!");
        Thread.sleep(3000); //让任务执行慢点
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

当这个线程放到线程池中循环执行

```
for (int i = 1; i <= 100; i++) {
    MyTask task = new MyTask(String.valueOf(i));

    while (i==20){
        executor.shutdownNow();
    }
    executor.execute(task);
}
```

当调用线程池shutdownNow方法则会抛出异常

corePoolSize

maximumPoolSize

keepAliveTime

TimeUnit

BlockingQueue<Runnable>

ThreadFatory

RejectedExecutionHandler

shutdownNow（）与shutdown（）

<http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95>